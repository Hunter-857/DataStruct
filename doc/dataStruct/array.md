## 数组
   * 一种最基础的线性结构
###  二分查找
   

   
###  滑动窗口
典型的快慢双指针，快慢指针中间就是滑动的「窗口」，主要用于解决子串问题
   
###  前追前缀和技巧 和 差分数组



Java 中ArrayList 的实现与数组的对比
Java 中ArrayList 自动扩容，那么扩容阈值时多少

## 链表
### 实现方式
指针，二维数组实现
二维数组感觉比较二啊 哈哈
#### 常见的链表类型
* 基本的链表
* 双向链表
* 循环链表
* 广义链表
* 双向循环链表

java中LinkedHashMap就是使用了双向链表,牺牲空间换取时间

链表中的哨兵机制

合并删除链表倒数第n个结点
求链表的中间结点

缓存淘汰算法

* 先进先出（FIFO)
* 最少使用 (LFU)
* 最近最少使用(LRU)

如何基于链表实现LRU缓存淘汰算法？
我的思路是这样的：

我们维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。
当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。

1. 如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。

2. 如果此数据没有在缓存链表中，又可以分为两种情况：如果此时缓存未满，则将此结点直接插入到链表的头部；如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。
这样我们就用链表实现了一个LRU缓存，是不是很简单？现在我们来看下m缓存访问的时间复杂度是多少。
因为不管缓存有没有满，我们都需要遍历一遍链表，所以这种基于链表的实现思路，缓存访问的时间复杂度为O(n)。
实际上，我们可以继续优化这个实现思路，比如引入散列表（Hash table）来记录每个数据的位置，将缓存访问的时间复杂度降到O(1)。
因为要涉及我们还没有讲到的数据结构，所以这个优化方案，我现在就不详细说了，等讲到散列表的时候，我会再拿出来讲。
除了基于链表的实现思路，实际上还可以用数组来实现LRU缓存淘汰策略。
如何利用数组实现LRU缓存淘汰策略呢？我把这个问题留给你思考

简单题:

单链表反转

21. 合并两个有序链表（简单）

23. 合并K个升序链表（困难）

141. 环形链表（简单）

142. 环形链表 II（中等）

876. [链表的中间结点（简单](../src/main/java/link/leetcode234.java)

19. 删除链表的倒数第 N 个结点（中等）

160. 相交链表（简单）


[leetcode_83 链表](../src/main/java/link/leetcode83.java)

[leetcode_21 合并链表](../src/main/java/link/leetcode21.java)

[leetcode_141&&142 环形链表](../src/main/java/link/leetcode141.java)

[leetcode_160 相交链表](../src/main/java/link/leetcode160.java)

## 队列

利用队列的广度搜索

## 栈

利用堆栈的深度搜索
